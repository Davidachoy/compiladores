package codigo;

import java_cup.runtime.Symbol;

//manejo tabla de simbolos
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;

//class Myparsec
action code {:

    HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash;

    public void imprimirTablaSimbolos(){
        for (String key : listaTablasSimbolos.keySet()){
            System.out.println("Tabla de simbolo: "+ key);
            System.out.println("Valores: ");
            for (String item : listaTablasSimbolos.get(key)){
                 System.out.println(item);
            }
            
            System.out.println("");
        }
    }
:}

// Sección para el código del parser

parser code
{:
    private Symbol s;

    // Método que se invoca cuando ocurre un error de sintaxis
   public void syntax_error(Symbol s){
    if (s == null) {
        System.err.println("El objeto Symbol proporcionado es nulo.");
        return;
    }
    this.s = s;
    System.err.println("Error de sintaxis en la línea " + s.left + ", columna " + s.right + ": se encontró " + s.value);
}

    // Devuelve el símbolo actual
    public Symbol getS(){
        return this.s;
    }
:};


// Terminales

terminal INT, FLOAT, BOOL, CHAR, STRING, IDENTIFICADOR, COMA, LLAVE_ABIERTA,
         LLAVE_CERRADA, PARENTESIS_ABIERTO, PARENTESIS_CERRADO,
         IGUAL, LITERAL_INT, LITERAL_FLOAT,
         LITERAL_CHAR, LITERAL_STRING,
         CORCHETE_ABIERTO,
         CORCHETE_CERRADO, IF, ELIF, ELSE, WHILE, FOR, DO, RETURN,
         READ, PRINT, MAIN, TRUE, FALSE, NEGACION, BREAK, MENOR_QUE,
         MENOR_IGUAL, MAYOR_QUE, MAYOR_IGUAL, IGUALES, DIFERENTES,SUMA,RESTA,
         MULTIPLICACION, DIVISION,MODULO, POTENCIA, ERROR,
         CONJUNCION, DISYUNCION, DOLAR,INCREMENTO,DECREMENTO;


// No terminales

non terminal inicio, funcion, nombre_funcion, tipo,identi_liter,
             identificador, parametros, param, cuerpo_funcion,
             bloque, sentencia, declaracion, asignacion,
             estructura_control, declaracion_if,term,nombre_main,
             expresion_logica, expresion_relacional,op_mult,izquierdaDeclaracion,
             asignacion_opcional, operador_logico, funciones,
             declaracion_for, inc_for, condicion_for,factor,declaracion_arreglo,
             declaracion_do_while, main, lectura, escritura, expresion,
             expresion_unaria, expresion_binaria, operador_unario,
             operador_binario, literal, literal_int,else_parte,array_expr,
             literal_float, literal_bool, literal_char, literal_string,
             llamada_funcion, parametrosInv, paramInv,declaracion_opcional,
             asignacion_arreglo,operador_relacional,identificadorFuncion;

// Precedencias

precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence left CONJUNCION, DISYUNCION;
precedence left MENOR_QUE, MENOR_IGUAL, MAYOR_QUE, MAYOR_IGUAL, IGUALES, DIFERENTES;
precedence right INCREMENTO, DECREMENTO, RESTA;

// Regla inicial

start with inicio;

// Reglas para la sección "inicio"

inicio::= main 
        | main funciones 
        | funciones main 
        | funciones main funciones;

funciones ::= funciones funcion:func1 
            {: System.out.println("/_---Cierra tabla simbolos:---_/"+func1+"\n\n\n"); :}
             | funcion:func1
            {: System.out.println("/_---Cierra tabla simbolos:---_/"+func1+"\n\n\n"); :}
             ;

main ::= nombre_main PARENTESIS_ABIERTO PARENTESIS_CERRADO cuerpo_funcion
            {: System.out.println("/_---Cierra tabla simbolos:---_/ \n\n\n"); :}
            ;

nombre_main::= INT:i MAIN:m
                {:
                        System.out.println("/_+++Nueva tabla de simbolos main ");
                        String tipoTabla;
                        tipoTabla = "tipo:main:" +i.toString();

                        ArrayList<String> funcionMain = new ArrayList<String>();
                        currentHash = m.toString();
                        funcionMain.add(tipoTabla);
                        listaTablasSimbolos.put(currentHash, funcionMain);
                        
                :}
                ;

cuerpo_funcion ::= LLAVE_ABIERTA bloque LLAVE_CERRADA;

funcion::= nombre_funcion cuerpo_funcion;

identificadorFuncion::= tipo:t IDENTIFICADOR:i
                {:
                        System.out.println("/_+++Nueva tabla de simbolos funcion " + i.toString());
                        String tipoTabla = "main";
                        if(i.toString().equals("main"))
                            tipoTabla = "tipo:main:" +t.toString();
                        else
                            tipoTabla = "tipo:funcion:"+ t.toString();

                        ArrayList<String> funcionMain = new ArrayList<String>();
                        currentHash = i.toString();
                        funcionMain.add(tipoTabla);
                        listaTablasSimbolos.put(currentHash, funcionMain);
                        
                :}
                ;


nombre_funcion ::= identificadorFuncion PARENTESIS_ABIERTO parametros PARENTESIS_CERRADO;

bloque ::= bloque sentencia  | sentencia;

// Reglas para la sección "estructura_control"

estructura_control::= declaracion_if 
                    | declaracion_do_while 
                    | declaracion_for;


asignacion_arreglo ::= identificador CORCHETE_ABIERTO expresion CORCHETE_CERRADO IGUAL expresion;

declaracion_arreglo ::= tipo identificador  CORCHETE_ABIERTO expresion CORCHETE_CERRADO;

declaracion_if ::= IF PARENTESIS_ABIERTO expresion_relacional PARENTESIS_CERRADO cuerpo_funcion else_parte;

else_parte ::= ELIF PARENTESIS_ABIERTO expresion_relacional PARENTESIS_CERRADO cuerpo_funcion else_parte
             | ELSE cuerpo_funcion
             |;

declaracion_for ::= FOR PARENTESIS_ABIERTO condicion_for PARENTESIS_CERRADO cuerpo_funcion;

condicion_for ::= asignacion DOLAR expresion_relacional DOLAR inc_for
                 |declaracion DOLAR expresion_relacional DOLAR inc_for;

declaracion_do_while ::= DO cuerpo_funcion WHILE PARENTESIS_ABIERTO expresion_relacional PARENTESIS_CERRADO DOLAR;

inc_for::=  INCREMENTO identificador
               | DECREMENTO identificador
               | asignacion;

// Reglas para las posibles sentencias

sentencia ::= declaracion 
            | asignacion DOLAR
            | estructura_control
            | lectura DOLAR
            | escritura DOLAR
            | asignacion_arreglo DOLAR
            | llamada_funcion DOLAR
            | RETURN expresion DOLAR
            | declaracion_arreglo DOLAR
            | BREAK DOLAR;




lectura ::= READ PARENTESIS_ABIERTO PARENTESIS_CERRADO 
           |READ PARENTESIS_ABIERTO identi_liter PARENTESIS_CERRADO;

escritura ::=  PRINT PARENTESIS_ABIERTO PARENTESIS_CERRADO
              |PRINT PARENTESIS_ABIERTO identi_liter PARENTESIS_CERRADO;

// Reglas para las posibles expressiones

expresion ::= expresion_relacional;

expresion_relacional::= expresion_logica 
                      | expresion_relacional operador_logico expresion_relacional
                      | expresion_logica operador_relacional expresion_logica
                      |expresion_relacional operador_relacional expresion_relacional;

expresion_logica::=   expresion_binaria
                    | expresion_logica operador_logico expresion_logica
                    | NEGACION expresion_logica ;

expresion_binaria ::= term 
                    | expresion_binaria:e1 SUMA term:e2 {: RESULT = e1 +"+"+ e2 ;:}
                    | expresion_binaria:e1  RESTA term:e2 {: RESULT = e1 +"-"+ e2;:}
                    | expresion_binaria:e1  POTENCIA term:e2 {:RESULT = e1 +"**"+ e2;:}
                    | expresion_binaria:e1  MULTIPLICACION term:e2 {:RESULT = e1 +"*"+ e2;:}
                    | expresion_binaria:e1  MODULO term:e2 {:RESULT = e1 +"~"+ e2;:}
                    | expresion_binaria:e1  DIVISION term:e2 {:RESULT = e1 +"/"+ e2;:}
                    ;



                    
term ::=  factor
        | term op_mult factor;

factor ::=    LITERAL_INT:n {:RESULT = n.toString();  System.out.println("Parser: literal int en expresion: "+ n.toString()); :}
            | LITERAL_FLOAT:n {:RESULT = n.toString();  System.out.println("Parser: literal float en expresion: "+ n.toString()); :}
            | TRUE:n {:RESULT = n;  System.out.println("Parser: literal bool en expresion: "+ n); :}
            | FALSE:n {:RESULT = n;  System.out.println("Parser: literal bool en expresion: "+ n); :}
            | LITERAL_CHAR:n {:RESULT = "@"+n+"@";  System.out.println("Parser: literal char en expresion: "+ n); :}
            | LITERAL_STRING:n {:RESULT = "/_"+n+"_/";  System.out.println("Parser: literal string en expresion: "+ n); :}
            | identificador:n {:RESULT = n;  System.out.println("Parser: identificador en expresion: "+ n); :}
            | llamada_funcion 
            | operador_unario factor
            | expresion_unaria
            | PARENTESIS_ABIERTO expresion PARENTESIS_CERRADO:n {:RESULT = n;:}
            | array_expr;


array_expr ::= identificador CORCHETE_ABIERTO expresion CORCHETE_CERRADO;

identificador ::= IDENTIFICADOR;

llamada_funcion ::= identificador PARENTESIS_ABIERTO parametrosInv PARENTESIS_CERRADO 
                | identificador PARENTESIS_ABIERTO PARENTESIS_CERRADO ;

parametros ::=    param 
                | parametros COMA param
                |;

param ::= tipo identificador;

tipo ::= INT    {:RESULT = "int";:}
       | FLOAT  {:RESULT = "float";:}
       | BOOL   {:RESULT = "bool";:}
       | CHAR   {:RESULT = "char";:}
       | STRING {:RESULT = "string";:}
       ;

parametrosInv ::= parametrosInv COMA paramInv
                 |paramInv;
                
paramInv ::= identificador | literal   ;


identi_liter ::= identificador
                |literal;

// Literales

literal ::=   literal_int
            | literal_float
            | literal_bool
            | literal_char
            | literal_string;

literal_int ::= LITERAL_INT:n {:RESULT = n.toString();:};
literal_float ::= LITERAL_FLOAT:n {:RESULT = n.toString();:}; 
literal_bool ::= TRUE | FALSE:n {:RESULT = n.toString();:};
literal_char::= LITERAL_CHAR:n {:RESULT = n.toString();:};
literal_string::= LITERAL_STRING:n {:RESULT = n.toString();:};

declaracion ::= izquierdaDeclaracion declaracion_opcional DOLAR;


izquierdaDeclaracion ::= tipo:t IDENTIFICADOR:idVar
                {:
                    System.out.println("Parser: identificador(agregar o verificar) "+ idVar.toString());
                    listaTablasSimbolos.get(currentHash).add(idVar.toString()+":"+t.toString());
                 :}
;





asignacion ::= IDENTIFICADOR:idVar asignacion_opcional
            {:
                                    
                    System.out.println("Parser: identificador(agregar o verificar) "+ idVar.toString());
                    listaTablasSimbolos.get(currentHash).add(idVar.toString());
               
            :}
;



// operadores
op_mult ::=   MULTIPLICACION
            | MODULO
            | DIVISION;

operador_relacional ::= MENOR_QUE
                      | MENOR_IGUAL
                      | MAYOR_QUE
                      | MAYOR_IGUAL
                      | IGUALES
                      | DIFERENTES;
  
operador_unario::=  INCREMENTO
                   | DECREMENTO
                   | RESTA;

operador_logico ::= CONJUNCION
                   |DISYUNCION;

declaracion_opcional ::= IGUAL expresion 
                      | IGUAL lectura
                      | IGUAL escritura
                      | ;

asignacion_opcional ::= IGUAL expresion 
                      | IGUAL lectura 
                      | IGUAL escritura 
                      | ;